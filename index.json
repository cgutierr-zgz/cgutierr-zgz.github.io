[{"content":"","date":"16 November 2022","permalink":"/","section":"cgutierr-zgz","summary":"","title":"cgutierr-zgz"},{"content":"","date":"16 November 2022","permalink":"/tags/dart/","section":"Tags","summary":"","title":"dart"},{"content":"","date":"16 November 2022","permalink":"/tags/dio/","section":"Tags","summary":"","title":"dio"},{"content":"","date":"16 November 2022","permalink":"/tags/flutter/","section":"Tags","summary":"","title":"flutter"},{"content":"","date":"16 November 2022","permalink":"/tags/interceptors/","section":"Tags","summary":"","title":"interceptors"},{"content":"","date":"16 November 2022","permalink":"/tags/logger/","section":"Tags","summary":"","title":"logger"},{"content":"","date":"16 November 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"16 November 2022","permalink":"/tags/retry/","section":"Tags","summary":"","title":"retry"},{"content":"dio by Flutterchina\nIn this post, I\u0026rsquo;ll show you how to use dio to make HTTP requests and how to use interceptors to refresh tokens and retry failed requests, everything while easily logging the requests and responses. This post was made using:\ndio version 4.0.6 dio_smart_retry version 1.3.2 pretty_dio_logger version 1.1.1 What is dio? üßê # Dio is a powerful Http client for Dart, which supports Interceptors, Global configuration, FormData, Request Cancellation, File downloading, Timeout etc.\nConcepts we will be covering in this post:\nInterceptors Interceptors are a way to intercept and modify http requests before they are sent to the server and to intercept and modify http responses before they are returned to the caller. Loggers A logger is a way to log the requests and responses to the console. Retries A retry is a way to retry a failed request. Token and Refresh Token A token is a way to authenticate a user and a refresh token is a way to refresh that token when it expires. Setting up dio üîß # To use dio, you need to add it to your pubspec.yaml file:\ndependencies: dio: ^4.0.6 dio_smart_retry: ^1.3.2 # optional pretty_dio_logger: ^1.1.1 # optional The dio_smart_try and pretty_dio_logger packages are optional, but I\u0026rsquo;ll be using them in this post, it\u0026rsquo;s an easy way to log the requests and responses and to retry failed requests, but we will make our own retry interceptor for the refresh token part.\nI also make use of flutter_appauth and flutter_secure_storage in the example found in the repo.\nMaking our custom dio client üöÄ # To make a request, you need to create a Dio instance and use the get method to make a GET request:\nfinal dio = Dio(); final response = await dio.get\u0026lt;dynamic\u0026gt;( \u0026#39;https://jsonplaceholder.typicode.com/todos/1\u0026#39;, ); print(response.data); Let\u0026rsquo;s now create a custom Dio client that we can use in our app:\nclass DioClient extends DioForNative { DioClient({ List\u0026lt;Interceptor\u0026gt;? interceptors, BaseOptions? options, int timeOutInMilliseconds = 30 * 1000, }) : super( options ?? BaseOptions( connectTimeout: timeOutInMilliseconds, sendTimeout: timeOutInMilliseconds, receiveTimeout: timeOutInMilliseconds, ), ); } Now we could simply use a new DioClient instance instence of the Dio in the example above.\nInterceptors ‚õìÔ∏è # Let\u0026rsquo;s now add some interceptors to our DioClient:\nclass DioClient extends DioForNative { DioClient(/*...*/) : super(/*...*/) { this.interceptors.addAll( [ // Whatever interceptors you want to add from the constructor ...?interceptors, ], ); } } That\u0026rsquo;s just adding the interceptors passed in the constructor to the interceptors list of the Dio instance. Let\u0026rsquo;s now have a look at the interceptors we will be using in this post.\nLogger interceptor üìú # The PrettyDioLogger is a simple interceptor that logs the requests and responses to the console, if you don\u0026rsquo;t want to use it you can make your own logger interceptor making use of the LogInterceptor class, here I\u0026rsquo;ll show you how to add both, choose the one you prefer.\n// ... this.interceptors.addAll( [ // ... previously added interceptors // Optionally add network Logger interceptor only for debug mode if (kDebugMode) ...[ // 1. PrettyDioLogger PrettyDioLogger( requestBody: true, responseBody: true, // ... other options requestHeader: false, responseHeader: false, error: false, request: false, ), // 2. LogInterceptor LogInterceptor( requestBody: true, responseBody: true, // ... other options requestHeader: false, responseHeader: false, error: false, request: false, logPrint: (log) { // Customice to your liking if (log.toString().isEmpty) return; debugPrint(\u0026#39;üåê ${log.toString()}\u0026#39;); }, ), ], ], ); // ... How does it look like in the console?\nPrettyDioLogger output: LogInterceptor output: Retry interceptor üîÅ # The RetryInterceptor is a simple interceptor that retries failed requests, there\u0026rsquo;s not much to it, you can pass the number of retries you want to make and the Dio instance will retry the request that many times.\n// ... this.interceptors.addAll( [ // ... previously added interceptors // RetryInterceptor -- has some more options, check the docs RetryInterceptor(dio: this, logPrint: print), ], ); // ... Token and Refresh Token interceptor üîë # I don\u0026rsquo;t really know an out-of-the-box solution, so I\u0026rsquo;ll be making my own interceptor to handle this.\nIn the AuthRepository class we will be using the flutter_appauth package to authenticate the user and the flutter_secure_storage package to store the tokens, you can read more about the implementation in the repo, take it as an example the repo does not have a complete implementation, it\u0026rsquo;s just an example.\nThe AuthRepository class will be used to authenticate the user and to refresh the token when it expires. To do so, we will add a new InterceptorsWrapper to the DioClient directly inside the AuthRepository class.\nThis wrapper will have two main methods, the onRequest method will be called before the request is sent to the server, and the onError method will be called before the response is returned to the caller.\nclass AuthRepository { AuthRepository({ required AuthProvider authProvider, required FlutterSecureStorage flutterSecureStorage, }) { _authProvider = authProvider; _secureStorage = flutterSecureStorage; final client = authProvider.client; client.interceptors.add( InterceptorsWrapper( onRequest: (request, handler) async { }, onError: (e, handler) async { }, ), ); } late final AuthProvider _authProvider; late final FlutterSecureStorage _secureStorage; // ... // Implementation of the signIn, checkSession, refreshToken, signOut, deleteTokens, etc... // Please, refer to the repo for more info about the implementation } The onRequest method will be used to add the Authorization header to the request, and the onError method will be used to refresh the token when it expires.\nLet\u0026rsquo;s now have a look at the implementation of the onRequest method:\nonRequest: (request, handler) async { // We add the accessToken to the headers if it\u0026#39;s not null final accessToken = await _secureStorage.read(key: _accessTokenKey); if (accessToken != null) { request.headers[\u0026#39;Authorization\u0026#39;] = \u0026#39;Bearer $accessToken\u0026#39;; } debugPrint(\u0026#39;[DIO]: Added accessToken [${accessToken != null}]\u0026#39;); return handler.next(request); }, Here we basically get the accessToken from the FlutterSecureStorage and add it to the request headers if it\u0026rsquo;s not null, then we call the handler.next(request) method to continue with the request.\nLike this we do not have to add the Authorization header to every request we make, we just have to add the DioClient instance to the AuthProvider class and we are good to go üòÑ\nNow let\u0026rsquo;s have a look at the implementation of the onError method:\nonError: (e, handler) async { // If the statuscode is 401 we try to refresh the token if (e.response?.statusCode == 401) { // We refresh the token await refreshTokens(); // We add the accessToken to the headers if it\u0026#39;s not null final accessToken = await _secureStorage.read( key: _accessTokenKey, ); if (accessToken != null) { debugPrint(\u0026#39;[DIO]: Refreshed Tokens\u0026#39;); e.requestOptions.headers[\u0026#39;Authorization\u0026#39;] = \u0026#39;Bearer $accessToken\u0026#39;; // Create request with new access token final opts = Options( method: e.requestOptions.method, headers: e.requestOptions.headers, ); final cloneReq = await client.request\u0026lt;void\u0026gt;( e.requestOptions.path, options: opts, data: e.requestOptions.data, queryParameters: e.requestOptions.queryParameters, ); return handler.resolve(cloneReq); } debugPrint(\u0026#34;[DIO]: Couldn\u0026#39;t refresh Tokens\u0026#34;); } }, Here we check if the status code of the response is 401, which, for our case, means that the token has expired, then we call the refreshTokens method to refresh the token, and we add the new accessToken to the request headers, then we create a new request with the new accessToken and we return the response to the caller.\nVoil√†, now we have a working interceptor that not only refreshes the token when it expires, but also adds the accessToken to the request headers, so we don\u0026rsquo;t have to üéâ\nConclusion üìù # In this post, I introduced you to the Dio package, I showed you how to use it to make HTTP requests, and I showed you how to use interceptors to add custom logic to the requests.\nTake this as an introduction to the Dio package, there\u0026rsquo;s a lot more to it, you can check the docs for more info.\nI hope you enjoyed it and that you found it useful.\nIf you have any questions or suggestions, feel free to leave a comment below. üòÑ\nThanks for reading! ü§ì\nThe full source code with for this post is available here üîç\nThe pubspec.yaml file for this project uses the following dependencies üì¶\ndependencies: dio: ^4.0.6 # To make HTTP requests and to use the interceptors I created dio_smart_retry: ^1.3.2 # Easy way to add retry logic to the requests flutter: sdk: flutter flutter_appauth: ^4.2.1 # Used to authenticate the user and to refresh the token flutter_secure_storage: ^6.0.0 # Used to store the tokens in the secure storage pretty_dio_logger: ^1.1.1 # For logging the requests dev_dependencies: flutter_test: sdk: flutter mocktail: ^0.3.0 # For mocking very_good_analysis: ^3.1.0 # Used to enforce very good practices ü¶Ñ References üìö # dio dio_smart_retry pretty_dio_logger flutter_appauth flutter_secure_storage ","date":"16 November 2022","permalink":"/posts/refreshing-auth-tokens-with-dio/","section":"Posts","summary":"Learn how to use dio and interceptors to refresh tokens and retry failed requests in a Flutter app.","title":"Retry, log and refresh auth tokens with Dio"},{"content":"","date":"16 November 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"9 November 2022","permalink":"/tags/enums/","section":"Tags","summary":"","title":"enums"},{"content":"","date":"9 November 2022","permalink":"/tags/go_router/","section":"Tags","summary":"","title":"go_router"},{"content":"go_router by Flutter.dev\nIn this post I want to show how I like to use the new enhanced enums with go_router. This can also apply if you use any other navigator, I just enjoy using go_router. This post was made using go_router version 5.1.5\nWhat are enhanced enums? ü§î # Enhanced enums are a great way to define a set of values that are known at compile time. They are similar to the enum type, but they can also have methods and properties.\nThe new enhanced enums are available since Dart 2.17\nHow to use enhanced enums üéØ # First, ensure your dart/flutter project is using at least Dart 2.17.0 in your pubspec.yaml:\nenvironment: sdk: \u0026#34;\u0026gt;=2.17.0 \u0026lt;3.0.0\u0026#34; Let\u0026rsquo;s start with a simple example. We want to define a set of routes for our app. We can do this by creating an enum:\nenum AppRoutes { login, home, settings, } Now that we have our enum, we can enhance it to define our routes, views, etc\u0026hellip;\nenum AppRoutes { login(\u0026#39;/login\u0026#39;, LoginPage()), home(\u0026#39;/home\u0026#39;, HomePage()), settings(\u0026#39;/settings\u0026#39;, SettingsPage()); // Don\u0026#39;t forget to add the semicolon here :) const AppRoutes( this.path, this.view, ); final String path; final Widget view; } That\u0026rsquo;s it! Now our enum has a path and a view.\nCombining enhanced enums with go_router üöÄ # Now that we have our enhanced enum, we can use it with go_router to define our routes.\nLet\u0026rsquo;s first add the go_router dependency to our pubspec.yaml:\ndependencies: go_router: ^5.1.5 And now let\u0026rsquo;s create our router:\nfinal router = GoRouter( initialLocation: AppRoutes.login.path, routes: [ GoRoute( path: AppRoutes.login.path, pageBuilder: (context, state) =\u0026gt; MaterialPage\u0026lt;void\u0026gt;( key: state.pageKey, child: AppRoutes.login.view, ), ), // ... same for home/settings using AppRoutes.x.path and x.home.view ], ); This already looks much better than the previous version, where we had to define the routes and views manually:\nfinal router = GoRouter( initialLocation: \u0026#39;/login\u0026#39;, routes: [ GoRoute( path: \u0026#39;/login\u0026#39;, pageBuilder: (context, state) =\u0026gt; MaterialPage\u0026lt;void\u0026gt;( key: state.pageKey, child: LoginPage(), ), ), // ... ); Anyway, we can make this even better by adding a method to our enum so that we can get the route directly from the enum just by calling AppRoutes.routeX.route:\nenum AppRoutes { // ... GoRoute get route =\u0026gt; GoRoute( path: path, pageBuilder: (context, state) =\u0026gt; MaterialPage\u0026lt;void\u0026gt;( key: state.pageKey, child: view, ), ); } This will allow us to simplify our router:\nfinal router = GoRouter( initialLocation: AppRoutes.login.path, routes: [ AppRoutes.login.route, AppRoutes.home.route, AppRoutes.settings.route, ], ); I like it picasso! üé®\nAdding our router üöß # Now that we have our router, we can add it to our app by updating our MaterialApp widget with a .router() constructor and adding a routerConfig parameter:\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp.router( title: \u0026#39;Enums and Router demo\u0026#39;, routerConfig: router, ); } } Now that we have our router, we can easily navigate to those known routes, let\u0026rsquo;s test it by adding a text button to the login page:\n//... TextButton( onPressed: () =\u0026gt; context.go(AppRoutes.home.path), child: Text(\u0026#39;Home\u0026#39;), ), //... We can even simplify this by adding another method to our enum:\nenum AppRoutes { // ... void go(BuildContext context) =\u0026gt; context.go(path); // Additionall, we can add push and replace methods :) void push(BuildContext context) =\u0026gt; context.push(path); void replace(BuildContext context) =\u0026gt; context.replace(path); } And now we can easily navigate to our with the use of our new methods:\n//... TextButton( onPressed: () =\u0026gt; AppRoutes.home.go(context), // onPressed: () =\u0026gt; AppRoutes.home.push(context), // onPressed: () =\u0026gt; AppRoutes.home.replace(context), child: Text(\u0026#39;Home\u0026#39;), ), //... Now navigating seems much easier and less error-prone üòÑ\nConclusion üìù # In this post, I showed you how I like to use enhanced enums with go_router in order navigate in a more type-safe, less error-prone and in my opinion more readable way.\nFor sure there are some use cases where this approach might not be the best, but I think it\u0026rsquo;s worth trying it out and see if it fits your needs üòâ\nI hope you enjoyed it and that you found it useful.\nIf you have any questions or suggestions, feel free to leave a comment below. üòÑ\nThanks for reading! ü§ì\nThe full source code with 94.5% test coverage üß™ for this post is available here üîç\nSorry, I couldn\u0026rsquo;t get it to 100% üòÖ I don\u0026rsquo;t really know how to test the pageBuilder, but feel free to open a PR if you know how to do it üòâ\nThe pubspec.yaml file for this project uses the following dependencies üì¶\ndependencies: flutter: sdk: flutter go_router: ^5.1.5 # Used to define our router dev_dependencies: flutter_test: sdk: flutter very_good_analysis: ^3.1.0 # Used to enforce very good practices ü¶Ñ References üìö # go_router Dart enums Dart 2.17.0 ","date":"9 November 2022","permalink":"/posts/go-router-enums/","section":"Posts","summary":"How to use enhanced enums with go_router to create a more type-safe navigation system.","title":"Using enhanced enums with go_router"},{"content":"","date":"8 November 2022","permalink":"/tags/bloc/","section":"Tags","summary":"","title":"bloc"},{"content":"","date":"8 November 2022","permalink":"/tags/hydrated_bloc/","section":"Tags","summary":"","title":"hydrated_bloc"},{"content":"hydrated_bloc by Felix Angelov\nIn this post, I\u0026rsquo;ll show you how to use hydrated_bloc to update and persist user settings like theme, language, etc. in a Flutter app.\nThis post was made using hydrated_bloc version 9.0.0\nWhat is hydrated_bloc? üßê # hydrated_bloc is a package that extends the bloc package to persist state changes to disk. This allows you to persist user settings, such as theme, language, and other preferences.\nhydrated_bloc uses hive as the underlying storage mechanism, which is a fast, NoSQL database that runs on mobile, desktop, and the web.\nSetup hydrated_bloc üõ†Ô∏è # To use hydrated_bloc, you need to add it to your pubspec.yaml file:\ndependencies: hydrated_bloc: ^9.0.0 Then, you need to initialize the storage. You can use the HydratedStorage.build() method to create a storage instance. You can then pass this instance to the HydratedBloc.storage property.\nIn this example, we will make use of the package path_provider to get the path to the app\u0026rsquo;s document directory and the HydratedStorage.webStorageDirectory for web. We will then use this paths to initialize the storage:\nvoid main() { WidgetsFlutterBinding.ensureInitialized(); HydratedBloc.storage = await HydratedStorage.build( storageDirectory: kIsWeb ? HydratedStorage.webStorageDirectory // for web : await getApplicationDocumentsDirectory(), // everything else ); // ... runApp } Using hydrated_bloc üéØ # Now that we have our storage initialized, we can start using hydrated_bloc. We will start by creating a Settings class, that will be used to store the user settings:\n@immutable class Settings extends Equatable { const Settings({ required this.themeMode, }); final ThemeMode themeMode; // ... place other settings here Settings copyWith({ThemeMode? themeMode}) =\u0026gt; Settings(themeMode: themeMode ?? this.themeMode); Map\u0026lt;String, dynamic\u0026gt; toJson() =\u0026gt; {\u0026#39;themeMode\u0026#39;: themeMode.index}; factory Settings.fromJson(Map\u0026lt;String, dynamic\u0026gt; map) =\u0026gt; Settings(themeMode: ThemeMode.values[map[\u0026#39;themeMode\u0026#39;] as int]); @override bool get stringify =\u0026gt; true; @override List\u0026lt;Object\u0026gt; get props =\u0026gt; [themeMode]; } Now that our user settings are defined, we can create a SettingsCubit that extends HydratedCubit, this cubit will be responsible for updating and persisting the user settings.\nWe will add a toggleThemeMode method to the cubit, that will be used to update the theme:\nclass SettingsCubit extends HydratedCubit\u0026lt;Settings\u0026gt; { SettingsCubit() : super(const Settings(themeMode: ThemeMode.system)); void toggleThemeMode(ThemeMode themeMode) =\u0026gt; emit(state.copyWith(themeMode: themeMode)); @override Settings fromJson(Map\u0026lt;String, dynamic\u0026gt; json) =\u0026gt; Settings.fromJson(json); @override Map\u0026lt;String, dynamic\u0026gt; toJson(Settings state) =\u0026gt; state.toJson(); } Important: Persisting multiple instances of the same cubit hydrated_bloc has a really cool feature which allows us to override a given id, this is useful when we want to have multiple instances of the same cubit. For example, if we want to have a SettingsCubit for each user, we can override the id property to use the user\u0026rsquo;s id:\n// ... final carlosCubit = SettingsCubit(\u0026#39;carlos\u0026#39;); final dimaCubit = SettingsCubit(\u0026#39;dima\u0026#39;); // ... class SettingsCubit extends HydratedCubit\u0026lt;Settings\u0026gt; { SettingsCubit(this._id) : super(const Settings(themeMode: ThemeMode.system)); final String _id; @override String get id =\u0026gt; _id; //... other methods } Since the data we want to persist is the user settings is safe to say that providing this at root level is a good idea.\nWe can do so by using a BlocProvider, thanks to the flutter_bloc package (dont forget to add it to your pubspec.yaml):\nvoid main() { // ... Setup storage runApp( // Provides the settings cubit to the root BlocProvider( create: (_) =\u0026gt; SettingsCubit(), child: const MyApp(), ), ); } Having the SettingsCubit available at root level, we can now use context.select to get the current theme mode and use it to set the theme mode of our app:\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Hydated Storage Demo\u0026#39;, theme: ThemeData.light(), darkTheme: ThemeData.dark(), // It only listen to the themeMode of the cubit themeMode: context.select((SettingsCubit c) =\u0026gt; c.state.themeMode), home: const SettingsPage(), ); } } Finally, let\u0026rsquo;s create a SettingsPage that will allow the user to change the theme mode:\nclass SettingsPage extends StatelessWidget { const SettingsPage({super.key}); @override Widget build(BuildContext context) { final themeMode = context.select( (SettingsCubit c) =\u0026gt; c.state.themeMode, ); return Scaffold( appBar: AppBar( title: const Text(\u0026#39;Settings Page\u0026#39;), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(\u0026#39;Current theme mode: $themeMode\u0026#39;), // Using the ThemeMode enum to get the available options ...List.generate( ThemeMode.values.length, (index) { final themeMode = ThemeMode.values[index]; return ElevatedButton( onPressed: () =\u0026gt; context.read\u0026lt;SettingsCubit\u0026gt;() .toggleThemeMode(themeMode), child: Text(themeMode.name), ); }, ), ], ), ), ); } } And... that's it! üéâ\nOur user settings are now persisted to disk and we could use them to update the app's theme, language, etc.\nEasy, right? üòÑ Conclusion üìù # In this post, I showed you how to use hydrated_bloc to update and persist user settings in a Flutter app. I hope you found this post useful.\nI hope you enjoyed it and that you found it useful.\nIf you have any questions or suggestions, feel free to leave a comment below. üòÑ\nThanks for reading! ü§ì\nThe full source code with 100% test coverage üß™ for this post is available here üîç\nThe pubspec.yaml file for this project uses the following dependencies üì¶\ndependencies: bloc: ^8.1.0 equatable: ^2.0.5 # Used to compare objects flutter: sdk: flutter flutter_bloc: ^8.1.1 # Used to provide the cubit to the root hydrated_bloc: ^9.0.0 # Used to persist the cubit state path_provider: ^2.0.11 # Used to get the storage directory path dev_dependencies: bloc_test: ^9.1.0 # Used to test the cubit flutter_test: sdk: flutter mocktail: ^0.3.0 # Used to mock the storage very_good_analysis: ^3.1.0 # Used to enforce very good practices ü¶Ñ References üìö # bloc equatable flutter_bloc hydrated_bloc hive path_provider bloc_test mocktail path very_good_analysis ","date":"8 November 2022","permalink":"/posts/storing-settings-with-hydrated-bloc/","section":"Posts","summary":"How to use hydrated_bloc to update and persist user settings in a Flutter app.","title":"Update and persist user settings with hydrated_bloc"},{"content":"","date":"3 November 2022","permalink":"/data-privacy/","section":"Data-privacies","summary":"","title":"Data-privacies"},{"content":"","date":"3 November 2022","permalink":"/tags/data-privacy/","section":"Tags","summary":"","title":"data-privacy"},{"content":"","date":"3 November 2022","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":"","date":"3 November 2022","permalink":"/tags/web/","section":"Tags","summary":"","title":"web"},{"content":"PRIVACY POLICY # This Privacy Policy sets forth the terms under which cgutierr-zgz.github.io uses and protects the information provided by its users when using its website. provided by its users at the time of using its website. We are committed to the security of its users\u0026rsquo; data. This Privacy Policy may change over time or be updated so we encourage and emphasize you to continually review this page. We encourage and emphasize that you continually review this page to ensure that you agree to any such changes.\nInformation that is collected # Our website does not collect any personal information or information of any kind.\nUse of information collected # We do not use the information in any way as we do not collect any information, we do not have analytics of any kind.\nCookies # A cookie refers to a file that is sent with the purpose of requesting permission to be stored on your computer. computer, when you accept this file is created and the cookie is then used to have information regarding web traffic, and also facilitates future visits to your web, and also facilitates future visits to a recurring website. Another function that cookies have is that with them the web can recognize you individually and therefore provide you with the best personalized service on its website.\nThe cookies that our web site could use are strictly necessary for the correct functioning of the site, but no data is stored in them. but no data is collected, analyzed or shared with third parties. You can delete cookies at any time from your browser or computer. However, cookies help to provide a better service of the websites. of the web sites, they do not give access to information from your computer or you, most browsers accept cookies automatically as it serves to have a better service cookies automatically as it serves to have a better web service. You can also change the configuration of your computer to decline cookies. If you decline cookies you may not be able to use some of our services.\nThird Party Links # This website may contain links to other sites that may be of interest to you. Once you click on Once you click on these links and leave our site, we no longer have control over the site to which you are redirected and therefore we are not responsible for the terms or we are not responsible for the terms or privacy or data protection of those other third party sites. These sites are subject to their own privacy policies and we recommend that you check with them to confirm that you agree to these policies. confirm that you agree with them.\nControl of your personal information # Because we do not collect any data, you do not need to control what personal information we have, This company will not sell, give or distribute any personal information, as it is not collected, and if it is, it will be with your consent. if it were, it would be with your explicit consent, unless required by a judge with a court order. cgutierr-zgz.github.io reserves the right to change the terms of this Privacy Policy at any time.\n","date":"3 November 2022","permalink":"/data-privacy/web-policy/","section":"Data-privacies","summary":"Data Privacy for cgutierr-zgz Website.","title":"Website"},{"content":"","date":"15 September 2022","permalink":"/tags/android/","section":"Tags","summary":"","title":"android"},{"content":"","date":"15 September 2022","permalink":"/tags/app/","section":"Tags","summary":"","title":"app"},{"content":"","date":"15 September 2022","permalink":"/tags/calculator/","section":"Tags","summary":"","title":"calculator"},{"content":"PRIVACY POLICY # This Privacy Policy sets forth the terms under which Calculator App uses and protects the information that is provided by its users when using the application. We are committed to the security of its users\u0026rsquo; data. This Privacy Policy may change over time or be updated from time to time so we encourage and emphasize you to continually review this page. We encourage and emphasize that you continually review this page to ensure that you agree to any such changes.\nInformation that is collected # Our application does not collect any personal information or information of any kind. Certain information is shared regarding the user\u0026rsquo;s interaction with the application, strictly related to interactions with advertisements, but that information does not contain user data. user data.\nUse of Information Collected # We do not use the information in any way because we do not collect any personal information. We only share ad-related data, all user data is stored on the phone itself and does not leave the device by any means. does not leave the device by any means.\nThird Party Links # The application may contain links to other sites that may be of interest to you. Once you click on Once you click on these links and leave our site, we no longer have control over the site to which you are redirected and therefore we are not responsible for any terms or we are not responsible for the terms or privacy or data protection of those other third party sites. These sites are subject to their own privacy policies and we recommend that you check with them to confirm that you agree to these policies. confirm that you are in agreement with these policies.\nControl of your personal information # Because we do not collect any data, you do not need to control what personal information we have, This company will not sell, give away or distribute any personal information, as it is not collected, and if it is, it will be with your consent. if it were, it would be with your explicit consent, unless required by a judge with a court order. Calculator App We reserve the right to change the terms of this Privacy Policy at any time.\n","date":"15 September 2022","permalink":"/data-privacy/calculator-privacy-policy/","section":"Data-privacies","summary":"Data Privacy for Calculator App.","title":"Calculator"},{"content":"","date":"11 September 2022","permalink":"/tags/flashlight/","section":"Tags","summary":"","title":"flashlight"},{"content":"PRIVACY POLICY # This Privacy Policy sets forth the terms under which Flashlight App uses and protects the information that is provided by its users when using the application. We are committed to the security of its users\u0026rsquo; data. This Privacy Policy may change over time or be updated from time to time so we encourage and emphasize you to continually review this page. We encourage and emphasize that you continually review this page to ensure that you agree to any such changes.\nInformation that is collected # Our application does not collect any personal information or information of any kind. Certain information is shared regarding the user\u0026rsquo;s interaction with the application, strictly related to interactions with advertisements, but that information does not contain user data. user data.\nUse of Information Collected # We do not use the information in any way because we do not collect any personal information. We only share ad-related data, all user data is stored on the phone itself and does not leave the device by any means. does not leave the device by any means.\nThird Party Links # The application may contain links to other sites that may be of interest to you. Once you click on Once you click on these links and leave our site, we no longer have control over the site to which you are redirected and therefore we are not responsible for any terms or we are not responsible for the terms or privacy or data protection of those other third party sites. These sites are subject to their own privacy policies and we recommend that you check with them to confirm that you agree to these policies. confirm that you are in agreement with these policies.\nControl of your personal information # Because we do not collect any data, you do not need to control what personal information we have, This company will not sell, give away or distribute any personal information, as it is not collected, and if it is, it will be with your consent. if it were, it would be with your explicit consent, unless required by a judge with a court order. Flashlight App We reserve the right to change the terms of this Privacy Policy at any time.\n","date":"11 September 2022","permalink":"/data-privacy/flashlight-privacy-policy/","section":"Data-privacies","summary":"Data Privacy for Flashlight App.","title":"Flashlight"},{"content":"PRIVACY POLICY # This Privacy Policy sets forth the terms under which ACNH Guide. An Unofficial Animal Crossing Guide uses and protects the information that is provided by its users when using the application. We are committed to the security of its users\u0026rsquo; data. This Privacy Policy may change over time or be updated from time to time so we encourage and emphasize you to continually review this page. We encourage and emphasize that you continually review this page to ensure that you agree to any such changes.\nInformation that is collected # Our application does not collect any personal information or information of any kind, it only stores information regarding the user\u0026rsquo;s own progress that the user indicates. Some information is shared regarding the user\u0026rsquo;s interaction with the application, strictly related to interactions with advertisements, but that information does not contain user data. user data.\nUse of information collected # We do not use the information in any way because we do not collect any personal information. We only share ad-related data, all user data is stored on the phone itself and does not leave the device by any means. does not leave the device by any means.\nThird Party Links # The application may contain links to other sites that may be of interest to you. Once you click on Once you click on these links and leave our site, we no longer have control over the site to which you are redirected and therefore we are not responsible for any terms or we are not responsible for the terms or privacy or data protection of those other third party sites. These sites are subject to their own privacy policies and we recommend that you check with them to confirm that you agree to these policies. confirm that you are in agreement with these policies.\nControl of your personal information # Because we do not collect any data, you do not need to control what personal information we have, This company will not sell, give away or distribute any personal information, as it is not collected, and if it is, it will be with your consent. if it were, it would be with your explicit consent, unless required by a judge with a court order. ACNH Guide. An Unofficial Animal Crossing Guide We reserve the right to change the terms of this Privacy Policy at any time.\n","date":"15 April 2020","permalink":"/data-privacy/acnh-privacy-policy/","section":"Data-privacies","summary":"Data Privacy for ACNH Guide App.","title":"ACNH Guide An Unofficial Animal Crossing Guide"},{"content":"","date":"15 April 2020","permalink":"/tags/acnh-guide/","section":"Tags","summary":"","title":"acnh-guide"},{"content":" Hi üëã\nI\u0026rsquo;m Carlos I like to learn, share and create things\nI\u0026rsquo;m also a big fan of Flutter and Dart\nAbout me üê• # I\u0026rsquo;m a passionate software developer from Spain mainly focused on Mobile Development. I was born in Zaragoza, but I soon moved to Madrid. I started learning about programming as a kid, but I needed to figure out what I wanted to do with it. After high school, I decided to study game gevelopment at CEV, even tho I got to work on some different cool projects, I was not happy with what I was doing so I decided to change my career and start learning mobile development. I started studying at 42 and mobile development both at CEV and on my own, where I learned a lot about programming and mobile development. Soon after I was able to land my first job in the industry, and since then I\u0026rsquo;ve been able to learn a lot and be part of some fantastic projects.\nI\u0026rsquo;m looking forward collaborating in open source projects and sharing my knowledge with the community.\nSome more info üìã # üö¥‚Äç‚ôÄÔ∏è Cycling and swimming üê∂ I have two dogs, named Laisa and Phoebe üê¢ I have five turtles, named Cristina, Casemira, Victor, Cloe and Paqui üá™üá∏ I was born in Zaragoza, Spain üé§ I love singing, take me to karaoke! Skills üíª # dart flutter bloc firebase platform channels A/B Testing analytics CI/CD devops android kotlin java unity3d c# maya zbrush photoshop substance painter Compaines I\u0026rsquo;ve worked for üíº # Aug 2022 - Present\nFlutter Developer ¬∑ LeadTech\nMay 2022 - Present\nFreelance DevOps Engineer ¬∑ The Publicator\nAug 2021 - Aug 2022\nFlutter Developer ¬∑ BASF\nFeb 2021 - Aug 2021\nFreelance Mobile Developer ¬∑ YoDA\nAug 2021 - Aug 2022\nSoftware Developer ¬∑ Telef√≥nica\nJan 2019 - Jan 2020\nUnity Developer ¬∑ Imagina Bienestar\nMar 2016 - Jun 2016\nUnity Developer ¬∑ Vanadis\nDownload cv Might not be super up-to-date, for that, please refer to my LinkedIn profile\nFeel free to contact me via email ‚úâÔ∏è ","date":"1 January 0001","permalink":"/about/","section":"cgutierr-zgz","summary":"About me","title":"About"}]